lane;
      
      function updatePlaneSize() {
        // Convert CSS element to canvas and create/update the texture
        html2canvas(cssElement).then(canvas => {
          const texture = new THREE.CanvasTexture(canvas);
          texture.needsUpdate = true;
      
          // Calculate the plane size based on the camera's frustum
          const distance = camera.position.z; // Distance from camera to the plane
          const frustumHeight = 2 * Math.tan(THREE.Math.degToRad(camera.fov) / 2) * distance;
          const frustumWidth = frustumHeight * camera.aspect;
      
          if (cssPlane) {
            cssPlane.material.map = texture;
            cssPlane.material.needsUpdate = true;
            cssPlane.geometry.dispose();
            cssPlane.geometry = new THREE.PlaneGeometry(frustumWidth, frustumHeight);
          } else {
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            cssPlane = new THREE.Mesh(new THREE.PlaneGeometry(frustumWidth, frustumHeight), material);
            cssPlane.position.set(0, 0, -distance);  // Position the plane to fit the screen view
            scene.add(cssPlane);
          }
        });
      }
      
      // Initial texture creation and plane setup
      updatePlaneSize();
      
      // Update the plane size and texture on window resize
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        updatePlaneSize();  // Update plane on resize
      });
