<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      * {
        padding: 0px;
        margin: 0px;
        box-sizing: border-box;
      }
      body {
        background-color: #ffffff;
      }
      div.visaul {
        width: 100vw;
        height: 100vh;
        padding: 40px 20px;
        background-image: url(w_00_intro_01_black.png);
        /* z-index: 2; */
        /* mix-blend-mode: multiply; */
      }
      #info {
        position: absolute;
        top: 100px;
        width: 100%;
        max-width: 1640px;
      }
      #info.p {
        width: 100%;
        text-align: right;
        display:block;
        color: var(--brand-gray-50, #313135);
        text-align: right;
        font-family: Pretendard;
        font-size: 160px;
        font-style: normal;
        font-weight: 700;
        line-height: 105%; /* 168px */
      }
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
      }
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div class="visaul" id="visual">
      <!-- <div id="info"><P>REMARKABLE<br>CONFIDENT<br>EXPERTS</P></div> -->
    </div>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { RoundedBoxGeometry } from "three/addons/geometries/RoundedBoxGeometry.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { LuminosityHighPassShader } from "three/addons/shaders/LuminosityHighPassShader.js";
      import { CopyShader } from "three/addons/shaders/CopyShader.js";
      import { Group } from "https://cdn.jsdelivr.net/npm/three@0.169.0/src/objects/Group.js";
      import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

      // ============Renderer============
      const renderer = new THREE.WebGLRenderer({ 
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight,1,2000);
      document.body.appendChild(renderer.domElement);

      // Renderer 설정
      renderer.outputEncoding = THREE.sRGBEncoding; // 색상 설정
      renderer.toneMapping = THREE.ACESFilmicToneMapping; // 톤 설정
      // renderer.toneMappingExposure = 1.1; // 노출 설정
      renderer.setClearColor(0x000000, 0);

      // ============Scene============
      const scene = new THREE.Scene();
      scene.background = null;

      // ============Camera============
      const camera = new THREE.PerspectiveCamera(44, window.innerWidth / window.innerHeight);
      camera.position.z = 5;
      camera.lookAt(0, 0, 0);

      // 창 크기 변경 시 리사이즈 처리
      window.addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }); 


      // ============후처리 효과 설정============
      const options = {
        bloomThreshold: 0.95,
        bloomStrength: 0.18,
        bloomRadius: 0.1,
      };
      const renderPass = new RenderPass(scene, camera); 
      // renderPass.clear=false;
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        options.bloomStrength,
        options.bloomRadius,
        options.bloomThreshold
      );
      
      const composer = new EffectComposer(renderer); // 후처리 효과를 위한 composer
      composer.addPass(renderPass);
      composer.addPass(bloomPass);

      // ============조명 설정============
      const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.5);
      scene.add(ambientLight);

      // const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.5);
      // directionalLight.position.set(0.5, 0.5, 0.3);

      // scene.add(directionalLight);

      // ============맵 설정============
      const hdrEquirect = new RGBELoader().load(
        "royal_esplanade_1k.hdr",
        () => {
          hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
          // scene.environment = hdrEquirect;
        }
      );

      const cubeMap = new THREE.CubeTextureLoader().load([
          'glass_map.png', // 오른쪽(px)
          'glass_map.png', // 왼쪽(nx)
          'glass_map.png', // 위(py)
          'glass_map.png', // 아래(ny)
          'glass_map.png', // 앞(pz)
          'glass_map.png'  // 뒤(nz)
      ]);


      
      // ============CSS to WebGL Texture============
      
      const cssElement = document.getElementById("visual");
      let cssPlane;

      function updatePlaneSize() {
        // Convert CSS element to canvas and create/update the texture
        html2canvas(cssElement).then(canvas => {
          const texture = new THREE.CanvasTexture(canvas);
          const planeWidth = 2 * camera.aspect;
          const planeHeight = 2;

          // If the plane already exists, update its material texture and geometry
          if (cssPlane) {
            cssPlane.material.map = texture;
            cssPlane.material.needsUpdate = true;
            cssPlane.geometry.dispose();
            cssPlane.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
          } else {
            // If the plane doesn't exist, create it
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            cssPlane = new THREE.Mesh(new THREE.PlaneGeometry(planeWidth, planeHeight), material);
            scene.add(cssPlane);
          }
        });
      }

      // Initial texture creation and plane setup
      updatePlaneSize();

      // Update the plane size and texture on window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
        updatePlaneSize();
      });
      
      // ============Meshes============
      // GLTF 로드
      new GLTFLoader().load("reconers_logoLow_test.glb", (gltf) => {
        const model = gltf.scene;
        model.background = null;

        // 3D 모델의 앞면/뒷면을 각각 렌더하고 그룹으로 합침
        model.traverse((child) => {
            if (child.isMesh) {
              const geometry = child.geometry.clone();  // geometry 클론

              // 앞면 Material
              const materialNormal = new THREE.MeshPhysicalMaterial({
                side: THREE.BackSide,
                color: 0x0B6FE8, // 색상
                transmission: 1, // 투명도
                reflectivity: 1, // 반사
                roughness: 0, // 표면 거칠기
                metalness: 0.8, // 금속질
                thickness: 1, // 왜곡 두께감
                ior: 1.5, // 굴절률
                iridescence: 0.5, // 표면 RGB 왜곡
                envMap: hdrEquirect,  // 환경맵
                envMapIntensity: 1.5, // 환경맵 적용값
                clearcoat: 1, // 매끈한 광택 표면 두께감
                clearcoatRoughness: 0.1, // 광택 표면 거칠기
                specularColor: 0x1289F3, // 반사광 색상
                specularIntensity: 1, // 반사광 적용값
                sheen: 1, // 미광 광택 적용값
                sheenRoughness: 0.8, // 미광 표면 거칠기
                sheenColor: 0x007bff, // 미광 색상
              });

              // 반사광 Material
              const materialReflect = new THREE.MeshPhysicalMaterial({
                blending: THREE.AdditiveBlending,
                opacity: 0.2,
                reflectivity: 1, // 반사
                transmission: 1, // 투명도
                metalness: 0.1, // 금속질
                roughness: 0, // 표면 거칠기
                ior: 2, // 굴절률
                envMap: cubeMap,  // 환경맵
                envMapIntensity: 0.5, // 환경맵 적용값
              });

              // Mesh 생성
              const normalMesh = new THREE.Mesh(geometry, materialNormal);
              // const reflectMesh = new THREE.Mesh(geometry, materialReflect);


              // 그룹화
              const reconers = new THREE.Group();
              reconers.add(normalMesh);
              // reconers.add(reflectMesh);

              reconers.position.set(0,0,0);

              // 씬에 그룹 추가
              scene.add(reconers);
              window.reconers = reconers;
            }
          });
        });


      

    // ============ 애니메이션 ============
    let isDragging = false;
    let previousMousePosition = {
      x: 0,
      y: 0,
    };
    let rotationSpeed = 0.001;
    let originRotation = { x: Math.PI / 2, y: Math.PI / 4, z: Math.PI / 5 }; // 초기값
    let targetRotation = { x: Math.PI / 2, y: Math.PI / 4, z: Math.PI / 5 }; // 도형 각도 
    let inertia = { x: 0, y: 0 }; // 관성 속도
    let inertiaDecay = 0.95; // 관성이 감소하는 비율
    let rotationLimits = {
      x: { min: -Math.PI / 18, max: Math.PI / 18 }, // X축 -10도 ~ +10도
      z: { min: -Math.PI / 18, max: Math.PI / 18 }, // Z축 -10도 ~ +10도
    };

    const onMouseMove = function (event) {
      // 도형의 중앙을 기준으로 마우스 위치를 감지
      const mouseX = (event.clientX - window.innerWidth / 2) / (window.innerWidth / 2); // [-1, 1] 범위로 변환
      const mouseY = -(event.clientY - window.innerHeight / 2) / (window.innerHeight / 2); // [-1, 1] 범위로 변환
      // 마우스 위치에 따라 목표 회전 각도를 계산
      targetRotation.x = originRotation.x + (-mouseY * rotationLimits.x.max); // X축 회전 (위/아래)
      targetRotation.z = originRotation.z - (mouseX * rotationLimits.z.max); // Z축 회전 (좌/우), 반대 방향으로 회전
      // 회전 제한 적용
      applyRotationLimits();
    };

    const onMouseOut = function (event) {
      // 마우스가 창 밖으로 나갈 때만 실행
      if (!event.relatedTarget && !event.toElement) {
        targetRotation.x = originRotation.x;
        targetRotation.z = originRotation.z;
      }
    };

    const applyRotationLimits = () => {
      // X축 회전 제한
      window.reconers.rotation.x = Math.max(
        rotationLimits.x.min,
        Math.min(rotationLimits.x.max, targetRotation.x)
      );
      // Z축 회전 제한
      window.reconers.rotation.z = Math.max(
        rotationLimits.z.min,
        Math.min(rotationLimits.z.max, targetRotation.z)
      );
    };

    // 마우스 이벤트 리스너 등록
    window.addEventListener("mousemove", onMouseMove, false);
    window.addEventListener("mouseout", onMouseOut, false);

    function animate() {
      requestAnimationFrame(animate);

      // 도형이 항상 마우스를 바라보도록 설정
      window.reconers.rotation.x = targetRotation.x;
      window.reconers.rotation.z = targetRotation.z;

      composer.render(); // 후처리 효과 렌더링
      // renderer.render( scene, camera );

      
    }

    animate();
    </script>
  </body>
</html>
    </script>
  </body>
</html>
