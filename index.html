<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      * {
        padding: 0px;
        margin: 0px;
        box-sizing: border-box;
      }
      body {
        background-color: #ebf0f8;
      }
      div.visaul {
        width: 100vw;
        height: 100vh;
        padding: 40px 20px;
      }
      div.text {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        justify-content: space-between;
        gap: 24px;
        flex: 1 0 0;
        width: 100%;
        height: 100%;
        min-height: fit-content;
      }
      div.text > * {
        font-family: "pretendard", sans-serif;
        font-size: 160px;
        font-weight: 400;
        line-height: 120%;
        color: #1d1d1f;
      }
      canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: transparent;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/"
        }
      }
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div class="visaul">
      <div class="text">
        <div>
          <p>RECONERS</p>
        </div>
        <div>
          <p>CREATE</p>
          <p>THE POSITIVE WAVES.</p>
        </div>
      </div>
    </div>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { RoundedBoxGeometry } from "three/addons/geometries/RoundedBoxGeometry.js";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { RGBELoader } from "three/addons/loaders/RGBELoader.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { LuminosityHighPassShader } from "three/addons/shaders/LuminosityHighPassShader.js";
      import { CopyShader } from "three/addons/shaders/CopyShader.js";

      // Scene 생성
      const scene = new THREE.Scene();

      // Camera 설정
      const camera = new THREE.PerspectiveCamera(
        40,
        window.innerWidth / window.innerHeight
      );
      camera.position.z = 5;
      camera.lookAt(0, 0, 0);

      // Renderer 설정
      const renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }); // 창 크기 변경 시 리사이즈 처리

      
      // 후처리 효과
      const options = {
        bloomThreshold: 0.95,
        bloomStrength: 0.14,
        bloomRadius: 0.1,
      };
      const renderPass = new RenderPass(scene, camera); 
      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        options.bloomStrength,
        options.bloomRadius,
        options.bloomThreshold
      );

      const composer = new EffectComposer(renderer); // 후처리 효과를 위한 composer
      composer.addPass(renderPass);
      composer.addPass(bloomPass);

      // 조명
      // const frontLight = new THREE.DirectionalLight(0xfff0dd, 0.1);
      // frontLight.position.set(1, 4, 0);
      // scene.add(frontLight);

      // 환경맵
      const hdrEquirect = new RGBELoader().load(
        "empty_warehouse_01_1k.hdr",
        () => {
          hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
          scene.environment = hdrEquirect;
          environmentMap.encoding = THREE.sRGBEncoding;
          renderer.toneMapping = THREE.ACESFilmicToneMapping;
          renderer.toneMappingExposure = 1;
        }
      );

      // 도형
      // const model = new GLTFLoader().load("sources\reconers_3d.glb", (gltf) => {
      //   gltf.scene.rotation.set(Math.PI / 2, 0, 0);
      // });

      // const geometry = model.geometry.clone();

      const geometry = new RoundedBoxGeometry(2, 2, 2, 16, 0.2);

      const material = new THREE.MeshPhysicalMaterial({
        transparent: true, // 투명도를 명시적으로 활성화
        transmission: 1, // 투명도 적용
        color: 0xe2eeff, // 컬러
        roughness: 0, // 거칠기
        thickness: 0.5, // 재질 두께 (왜곡에 영향)
        ior: 1.4, // 재질 왜곡
        envMap: hdrEquirect, // 환경 맵
        envMapIntensity: 1.5, // 환경 맵 적용 정도
        side: THREE.DoubleSide, // 도형 안팎 렌더
        clearcoat: 1,
        clearcoatRoughness: 0.1,
        iridescence: 0.7,
        iridescenceIOR: 1.5,
      });

      const reconers = new THREE.Mesh(geometry, material);
      // reconers.scale.set(0.135, 0.135, 0.135);
      scene.add(reconers);

      // BG
      const bgTexture = new THREE.TextureLoader().load("texture.jpg");
      const bgGeometry = new THREE.PlaneGeometry(40, 40);
      const bgMaterial = new THREE.MeshBasicMaterial({
        map: bgTexture,
        opacity: 1,
        depthTest: false, // 배경이 항상 그려지도록 설정
      });
      const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
      bgMesh.position.set(0, 0, -10);
      scene.add(bgMesh);

      // 애니메이션
      let isDragging = false;
      let previousMousePosition = {
        x: 0,
        y: 0,
      };

      let rotationSpeed = 0.001;
      let targetRotation = { x: 0, y: 0, z: 0 }; // Z축 추가
      let inertia = { x: 0, y: 0 }; // 관성 속도
      let inertiaDecay = 0.95; // 관성이 감소하는 비율
      let rotationLimits = {
        x: { min: -Math.PI / 18, max: Math.PI / 18 }, // X축 -10도 ~ +10도
        y: { min: -Math.PI / 18, max: Math.PI / 18 }, // Y축 -10도 ~ +10도
      };

      const onMouseMove = function (event) {
        // 도형의 중앙을 기준으로 마우스 위치를 감지
        const mouseX =
          (event.clientX - window.innerWidth / 2) / (window.innerWidth / 2); // [-1, 1] 범위로 변환
        const mouseY =
          -(event.clientY - window.innerHeight / 2) / (window.innerHeight / 2); // [-1, 1] 범위로 변환

        // 마우스 위치에 따라 목표 회전 각도를 계산
        targetRotation.x = -mouseY * rotationLimits.x.max; // Y축 회전 (위/아래)
        targetRotation.y = mouseX * rotationLimits.y.max; // X축 회전 (좌/우), 반대 방향으로 회전

        // 회전 제한 적용
        applyRotationLimits();
      };

      const applyRotationLimits = () => {
        // X축 회전 제한
        reconers.rotation.x = Math.max(
          rotationLimits.x.min,
          Math.min(rotationLimits.x.max, targetRotation.x)
        );
        // Y축 회전 제한
        reconers.rotation.y = Math.max(
          rotationLimits.y.min,
          Math.min(rotationLimits.y.max, targetRotation.y)
        );
      };

      // 마우스 이벤트 리스너 등록
      window.addEventListener("mousemove", onMouseMove, false);

      function animate() {
        requestAnimationFrame(animate);

        // 도형이 항상 마우스를 바라보도록 설정
        reconers.rotation.x = targetRotation.x;
        reconers.rotation.y = targetRotation.y;

        composer.render(); // 후처리 효과 렌더링
      }

      animate();
    </script>
  </body>
</html>
